# 입실 체크 해주세요 !!🎈
# JavaScript
## 조건문
### if-else if-else
### switch
  switch문에서는 조건문과 달리 비교 연산을 통한 true/false를 뽑아내는 식이 switch()의 소괄호 내에 들어가지 않습니다.
```js
switch(변수/상수) {
  case 값1:
    실행문1
    break;
  case 값2:
    실행문2
    break;
  default:
    실행문default;
    (break;)
}
```
- if문과 switch문의 차이
if문은 조건식 내에 비교 연산을 사용할 수 있기 때문에 switch문보다 더 자주 사용됩니다. 하지만 if문의 경우 조건식을 위에서부터 차례대로 순차 비교를 하기 때문에 운 나쁘게 맨 밑에 조건이 당첨된다면 그만큼 속도가 느려진다는 문제가 있습니다. 그래서 비교 연산이 필요 없고 조건을 비교할 대상이 범위가 아니라 특정 값인 경우에는 switch가 더 선호됩니다.

## 반복문
ch03_loops
- 종류
  1. for
  2. for-in
  3. for-of
  4. while
### for-loop
01_for_loop.js
### for-in-loop
- 이거 그냥 향상된 for문입니다.
- Java에서는 향상된 for문을 사용할 경우 인덱스 넘버가 없는 애들도 출력이 가능했습니다(Set 자료형의 경우).
- JS에서도 인덱스가 없는 자료형의 element를 추출할 때 for-in 반복문을 사용하게 됩니다.
- 가장 대표적으로는 JavaScript의 객체의 value를 추출할 수 있습니다.

### for-of-loop
- 근데 얘도 향상된 for문입니다.
- 03_for_of.js

# 함수(function)
## 정의
- 다양한 작업을 하나의 단위로 묶어놓은 코드블록
## 함수의 정의 및 사용
1. 함수 선언식
```js
function 함수명(매개변수1, 매개변수2) {
  실행문;
  return이 optional
}
function add(a, b) {
  let sum = a + b;
  return sum;
}
```
2. 함수의 호출
```js
let sumNum = add(1, 2);    //는 근데 아무런 콘솔상에서의 결과값이 없겠네요. return 썼으니까.
console.log(sumNum);
```
ch04_functions / 01_function1.js

3. 함수 표현식(arrow function)
02_function2.js
함수 표현식은 _변수에 함수를 할당해서 사용하는 방식_ 입니다.
- 어제 말한 것처럼 메서드의 결과값이 변수에 들어가는게 아니라 함수 자체가 변수에 들어갑니다.
- 형식
```js
선언자 변수명 = 함수명(매개변수1, 매개변수2) {
  실행문
  return값
}
let sum = function(a, b) {
  return a + b;
}
```

```js
let sum00 = sum(10, 5);   // 함수를 변수에 저장하니까 순서를 지키게 되어 오류가 발생
console.log(sum00);


// 함수 표현식 정의
let sum = function(a, b) {
  return a + b;
}
// 함수 호출
sum1 = sum(1, 2);
console.log(sum1);
sum2 = sum(3, 4);
console.log(sum2);
```
함수 및 함수 표현식의 경우 차이가 없어 보이지만 실행 측면 상에서의 차이가 존재합니다. 일반적인 함수 선언의 경우에는 정의 영역이 호출 영역보다 뒤에 있다고 하더라도 정상 작동을 합니다.

이는 JS 해석(인터프리터) 엔진이 일반적으로 선언된 함수의 경우 먼저 읽어들이기 때문에(호이스팅) 호출 구문이 선행하더라도 문제가 없습니다.

그런데 변수에 함수를 할당하는 함수 표현식의 경우 let 선언자로 인해 선언된 순서를 읽기 때문에 정의가 먼저 되어야지만 호출이 정상적으로 이루어집니다.

4. Function 생성자 함수
```js
let sum = new Function('a', 'b', 'return a + b;');
let sum1 = sum(1, 2);
let sum2 = sum(3, 4);
```
## 함수를 사용하는 이유
- 특정 기능을 하는 코드 블록을 작성하면 해당 함수가 갖는 기능이 필요할 때마다 호출만 하면 되기 때문에 효율성이 높습니다. 같은 코드를 재작성할 필요가 없기 때문에 장점이 있고, 또한 기능 변경이 일어날 때 전체 코드를 수정하는 게 아니라 특정 함수 내부의 로직만 수정하면 호출 부분은 자동으로 수정사항이 반영됩니다.

1. 코드의 재사용성이 높다. 
2. 코드의 유지보수성이 높다.
3. 함수의 이름이 직관적인 경우에 코드 가독성이 높다.